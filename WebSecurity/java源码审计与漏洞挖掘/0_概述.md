# Java 源码审计和漏洞挖掘 - 概述

## java 基础

### 运行环境
   - JDK, Java Development Kit
     - Java SE, Java Platform, Standard Edition
     - Java EE, Java Platform, Enterprise Edition
     - Java ME, Java Platform, Micro Edition
   - JRE, Java Runtime Environment
   - JVM, Java Virtual Machine

### 反射

1. 获取对象的 Class

```java
// 1. 硬编码了类
Class<?> cls1 = Integer.class;

// 2.
Class<?> cls2 = Class.forName("java.lang.Integer");

// 3.
String s = "";
Class<?> cls3 = s.getClass();
```

2. 生成实例

// Person.java
```java
public class Person {
    String name;
    int age;
    String mantra;

    public Person() {
        this.sayHello();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        this.sayHello();
    }

    public Person(String name, int age, String mantra) {
        this.name = name;
        this.age = age;
        this.mantra = mantra;
        this.sayHello();
    }

    public void sayHello() {
        System.out.println("I'm " + this.name + " " + this.age + " years old, " + this.mantra);
    }

    private void sayMantra() {
        System.out.println(this.name + ": " + this.mantra);
    }
}

```

// Main.java
```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Class<?> cls = Class.forName("Person");

        // 只能使用默认构造函数
        Object ins = cls.newInstance();

        // 可以通过参数列表, 获取指定的构造函数
        Constructor<?> c = cls.getConstructor(String.class, int.class);
        Object ins2 = c.newInstance("alice", 12);
    }
}
```

3. 方法调用

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Class<?> cls = Class.forName("Person");

        Constructor<?> c = cls.getConstructor(String.class, int.class, String.class);
        Object ins = c.newInstance("alice", 12, "kirito");

        // public method
        Method m1 = cls.getMethod("sayHello");
        m1.invoke(ins);

        // private method
        Method m2 = cls.getDeclaredMethod("sayMantra");
        m2.setAccessible(true);
        m2.invoke(ins);
    }
}
```

### JNDI, The Java Naming and Directory Interface

1. 提供的命名/目录服务:
   - LDAP
   - DNS
   - NIS
   - NDS
   - RMI
   - CORBA

2. demo

```java
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;

public class Jndi {
    public static void main(String[] args) throws NamingException {
        // 指定需要查找的name名称
        String jndiName = "rmi://www.baidu.com";

        // 初始化默认环境
        Context context = new InitialContext();

        // 查找[name]的数据
        DataSource ds = (DataSource) context.lookup(jndiName);

    }
}
```

4. reference
    - [JAVA JNDI 注入知识详解](https://paper.seebug.org/1207/)
    - [浅谈RMI - 搭建一个简单的RMI程序](https://blog.csdn.net/xiaoyaoyulinger/article/details/51452674)

### 序列化&反序列化

1. class 实现了 java.io.Serializable 接口才可以被反序列化, 且所有树形必须是可序列化的, static/transient 修饰的除外

### 动态加载字节码

1. 动态生成字节码相关技术
   - BCEL
   - Javassist
   - ASM
   - CGLib

2. ClassLoader

 可以把 磁盘, jar包, 内存等里的bytes数据转为class对象

 - loadClass
 - findClass
 - defineClass

demo:
```java
Class.forName("com.mysql.cj.jdbc.Driver")
Class<?>forName(String name, boolean initialize, ClassLoader cl)
```

## 方法论

1. 正向: 查找可控变量, 正向追踪变量传递过程
2. 逆向: 格局敏感关键字回溯参数传递过程
3. WEB-INF 存储了服务端的配置信息
4. web.xml存储了项目信息
5. 也可以从数据库, 包依赖等角度取巧

## 审计工具

1. Jetbrains IDEA
2. Sublime text
3. JD-GUI
4. Fernflower
5. Bytecode-Viewer
6. Eclipse
7. NetBeans